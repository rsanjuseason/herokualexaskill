'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _sql = require('./sql');

var _sql2 = _interopRequireDefault(_sql);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const makeAsyncApi = client => {

  let inQuery = false;

  function query(sql) {
    for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      values[_key - 1] = arguments[_key];
    }

    return query.queryArgs(sql, values);
  }

  let _queryArgs = (sql, values) => {
    if (sql instanceof _sql.SqlFragment) {
      values = sql.values;
      sql = sql.text;
    }

    inQuery = true;
    return new _bluebird2.default((resolve, reject) => {
      (0, _debug2.default)('query params: %s query: %j', JSON.stringify(values).slice(0, 60), sql);
      client.query(sql, values, (err, result) => {
        inQuery = false;
        if (err) {
          (0, _debug2.default)('%s query(%j, %j)', err, sql, values);
          return reject(err);
        }
        (0, _debug2.default)('query ok: %d rows', result.rowCount);
        return resolve(result);
      });
    });
  };

  query.SQL = _sql2.default;

  query.query = function (sql) {
    for (var _len2 = arguments.length, values = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      values[_key2 - 1] = arguments[_key2];
    }

    return query.queryArgs(sql, values);
  };
  query.queryArgs = (sql, values) => {
    if (inQuery) throw new Error('Commands on same client should be called serially. ' + 'Do you forget `await`?');
    return _queryArgs(sql, values);
  };

  query.rows = function (sql) {
    for (var _len3 = arguments.length, values = Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      values[_key3 - 1] = arguments[_key3];
    }

    return query.rowsArgs(sql, values);
  };
  query.rowsArgs = (sql, values) => query.queryArgs(sql, values).then(r => r.rows);

  query.row = function (sql) {
    for (var _len4 = arguments.length, values = Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      values[_key4 - 1] = arguments[_key4];
    }

    return query.rowArgs(sql, values);
  };
  query.rowArgs = (() => {
    var _ref = _asyncToGenerator(function* (sql, values) {
      const result = yield query.queryArgs(sql, values);
      if (result.rowCount !== 1) throw new Error(`SQL: Expected exactly one row result but ${ result.rowCount } returned`);
      return result.rows[0];
    });

    return function (_x, _x2) {
      return _ref.apply(this, arguments);
    };
  })();

  query.value = (() => {
    var _ref2 = _asyncToGenerator(function* (sql) {
      for (var _len5 = arguments.length, values = Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        values[_key5 - 1] = arguments[_key5];
      }

      return query.valueArgs(sql, values);
    });

    return function (_x3) {
      return _ref2.apply(this, arguments);
    };
  })();
  query.valueArgs = (() => {
    var _ref3 = _asyncToGenerator(function* (sql, values) {
      let opts;
      if (sql instanceof _sql.SqlFragment) {
        opts = _extends({}, sql, {
          rowMode: 'array'
        });
        values = sql.values;
      } else {
        opts = typeof sql === 'string' ? { text: sql, rowMode: 'array' } : _extends({}, sql, { rowMode: 'array' });
      }

      const result = yield query.rowArgs(opts, values);
      if (result.length !== 1) throw new Error(`SQL: Expected exactly one column but ${ result.length } returned`);
      return result[0];
    });

    return function (_x4, _x5) {
      return _ref3.apply(this, arguments);
    };
  })();

  query.inTransaction = false;

  query.startTransaction = () => {
    query.inTransaction = true;
    return query.query('BEGIN');
  };

  query.commit = () => {
    query.inTransaction = false;
    return query.query('COMMIT');
  };

  query.rollback = () => {
    query.inTransaction = false;
    return _queryArgs('ROLLBACK', []);
  };

  query._end = () => {
    const queryArgs = _queryArgs;
    _queryArgs = () => {
      throw new Error('Client was released.');
    };
    return new _bluebird2.default(resolve => {
      if (inQuery) throw new Error('Client shutting down but query is pending. ' + 'Do you forget `await`?');

      if (query.inTransaction) {
        query.inTransaction = false;
        queryArgs('ROLLBACK', []);
        throw new Error('Transaction started manually but not closed. Automatic rollback');
      }
      resolve();
    });
  };

  return query;
};

exports.default = makeAsyncApi;