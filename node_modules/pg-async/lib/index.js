'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SQL = exports.identifier = exports.literal = exports.sqlStr = undefined;

var _sql = require('./sql');

Object.defineProperty(exports, 'sqlStr', {
  enumerable: true,
  get: function get() {
    return _sql.sqlStr;
  }
});
Object.defineProperty(exports, 'literal', {
  enumerable: true,
  get: function get() {
    return _sql.literal;
  }
});
Object.defineProperty(exports, 'identifier', {
  enumerable: true,
  get: function get() {
    return _sql.identifier;
  }
});

var _bluebird = require('bluebird');

var _bluebird2 = _interopRequireDefault(_bluebird);

var _pg = require('pg');

var _pg2 = _interopRequireDefault(_pg);

var _debug = require('./debug');

var _debug2 = _interopRequireDefault(_debug);

var _makeAsyncApi = require('./makeAsyncApi');

var _makeAsyncApi2 = _interopRequireDefault(_makeAsyncApi);

var _sql2 = _interopRequireDefault(_sql);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new _bluebird2.default(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return _bluebird2.default.resolve(value).then(function (value) { step("next", value); }, function (err) { step("throw", err); }); } } return step("next"); }); }; }

const SQL = exports.SQL = _sql2.default;

function checkAsyncFunction(asyncFunc) {
  if (typeof asyncFunc !== 'function') throw new TypeError('async function expected');
}

class PgAsync {
  constructor(connectionOptions, driver) {
    this.SQL = _sql2.default;

    this.closeConnections = () => this.getDriver().end();

    this.setConnectionOptions(connectionOptions);
    this.setDriver(driver);

    const self = this;
    const wrap = name => {
      self[name] = function (sql) {
        for (var _len = arguments.length, values = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          values[_key - 1] = arguments[_key];
        }

        return self.connect(client => client[`${ name }Args`](sql, values));
      };
    };
    const wrapArgs = name => {
      self[name] = (sql, values) => self.connect(client => client[name](sql, values));
    };

    wrap('query');
    wrapArgs('queryArgs');

    wrap('rows');
    wrapArgs('rowsArgs');

    wrap('row');
    wrapArgs('rowArgs');

    wrap('value');
    wrapArgs('valueArgs');
  }

  setConnectionOptions(options) {
    this._connectionOptions = options;
    return this;
  }

  getConnectionOptions() {
    return this._connectionOptions || this.getDriver().defaults;
  }

  getDriver() {
    return this._driver;
  }

  setDriver(driver) {
    if (typeof driver === 'string') switch (driver) {
      case '':case 'pg':
        driver = _pg2.default;
        break;
      case 'native':case 'pg.native':
        driver = _pg2.default.native;
        break;
      default:
        throw new Error(`Unrecognized driver name: ${ driver }`);
    }
    this._driver = driver || _pg2.default;
    return this;
  }

  getClient() {
    var _this = this;

    return _asyncToGenerator(function* () {
      return new _bluebird2.default(function (resolve, reject) {
        _this.getDriver().connect(_this.getConnectionOptions(), function (err, client, _done) {
          if (err) {
            (0, _debug2.default)('%s getClient(%j)', err, _this.getConnectionOptions());
            if (_done) _done(err);
            return reject(err);
          }
          return resolve({
            client: client,
            done: function done() {
              (0, _debug2.default)('Client released');
              _done();
            }
          });
        });
      });
    })();
  }

  connect(asyncFunc) {
    var _this2 = this;

    return _asyncToGenerator(function* () {
      checkAsyncFunction(asyncFunc);

      var _ref = yield _this2.getClient();

      const client = _ref.client,
            done = _ref.done;

      try {
        const api = (0, _makeAsyncApi2.default)(client);
        const result = yield asyncFunc(api);
        yield api._end();
        done();
        return result;
      } catch (err) {
        done(err);
        throw err;
      }
    })();
  }

  transaction(asyncFunc) {
    var _this3 = this;

    return _asyncToGenerator(function* () {
      checkAsyncFunction(asyncFunc);

      return yield _this3.connect((() => {
        var _ref2 = _asyncToGenerator(function* (client) {
          client.checkSerialAccess = true;
          yield client.startTransaction();
          try {
            const result = yield asyncFunc(client);
            yield client.commit();
            return result;
          } catch (err) {
            try {
              yield client.rollback();
            } catch (_) {
              // client disconnected?
            }
            throw err;
          }
        });

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      })());
    })();
  }

}
exports.default = PgAsync;
PgAsync.SQL = _sql2.default;